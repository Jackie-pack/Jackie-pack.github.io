
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>文字平台跳跃 — 无限墙壁版</title>
  <style>
    html,body{height:100%;margin:0;background:#061025;color:#fff;font-family: 'Noto Sans SC','Microsoft Yahei',monospace}
    #gameWrap{display:flex;gap:12px;padding:12px}
    canvas{background:linear-gradient(180deg,#041220,#071821);border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
    #ui{min-width:260px}
    .panel{background:rgba(255,255,255,0.03);padding:12px;border-radius:8px}
    h1{font-size:18px;margin:0 0 8px 0}
    button{background:#1f6feb;border:0;padding:8px 10px;border-radius:6px;color:white;cursor:pointer}
    .small{font-size:13px;color:#b8d0ff}
    .bigScore{font-size:28px;margin:6px 0}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="c" width="960" height="480"></canvas>
    <div id="ui">
      <div class="panel">
        <h1>文字平台跳跃 — 无限版</h1>
        <div class="small">现在地图会**无限生成墙（"墙"）**，画面从右向左移动，你要不停跳跃并尽量活得更久。其他字符：'分' = 金币，'火' = 危险，'旗' = 奖励（很少出现）。</div>
        <div style="margin-top:8px">
          <div class="bigScore">得分: <span id="score">0</span></div>
          <div class="bigScore">死亡: <span id="deaths">0</span></div>
        </div>
        <div style="margin-top:10px">
          <button id="restartBtn">重开（重置全部）</button>
        </div>
        <hr style="margin:10px 0;border:none;border-top:1px solid rgba(255,255,255,0.04)">
        <div class="small">
          控制：← → / A D 移动，空格 跳跃，R 快速重生。墙会源源不断向左滚动，碰到“火”或掉下画面死亡。
        </div>
      </div>
      <div class="panel" style="margin-top:10px">
        <h1>玩法说明</h1>
        <div class="small">无限生成使用简单程序生成器：每一列（column）会随机决定要不要放平台（墙）与高度，会留出空隙做通道。金币/火/旗概率性出现在平台上。</div>
      </div>
    </div>
  </div>

<script>
// 无限生成墙壁版 — 单文件实现
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const deathsEl = document.getElementById('deaths');
const restartBtn = document.getElementById('restartBtn');

const TILE = 36;
const COLS = Math.floor(canvas.width / TILE);
const ROWS = Math.floor(canvas.height / TILE);

let score = 0, deaths = 0;
let mapCols = []; // array of columns, each column is array of ROWS chars

// player
const player = {
  x: canvas.width * 0.25,
  y: 0,
  w: TILE*0.6,
  h: TILE*0.9,
  vx:0, vy:0,
  speed:180,
  jumpPower:520,
  onGround:false
};

let keys = {};
window.addEventListener('keydown',e=>{ keys[e.key.toLowerCase()] = true; if(e.key.toLowerCase()==='r') respawn(); });
window.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()] = false; });

// utils
function emptyCol(){ return new Array(ROWS).fill(' '); }

function tileAt(col,row){ if(col<0) return ' '; if(row<0||row>=ROWS) return ' '; const c = mapCols[col]; if(!c) return ' '; return c[row]; }
function setTile(col,row,val){ if(col<0) return; if(row<0||row>=ROWS) return; if(!mapCols[col]) mapCols[col] = emptyCol(); mapCols[col][row] = val; }

function pushColumn(col){ mapCols.push(col); }
function shiftColumn(){ mapCols.shift(); }

// procedural generator state
let spawnTimer = 0;
const spawnInterval = 0.5; // seconds per column shift
let scrollAccumulator = 0;
let speedMultiplier = 1;

function generateColumn(){
  // generate a column with platforms (墙) at some contiguous heights
  const col = emptyCol();
  // decide whether this column contains a platform column (part of a platform)
  // We'll create platforms that are contiguous horizontally by using a simple run-length logic
  // Use a global generator state to produce runs
  if(!generateColumn._state) generateColumn._state = {runLeft:0, height: Math.floor(ROWS*0.6)};
  const s = generateColumn._state;
  if(s.runLeft > 0){
    // continue platform
    for(let r = s.height; r<ROWS; r++) col[r] = '墙';
    s.runLeft -= 1;
  } else {
    // decide whether to start a new platform run
    if(Math.random() < 0.55){
      s.runLeft = Math.floor(Math.random()*4) + 2; // length 2..5
      // vary height mildly
      const dh = Math.floor((Math.random()-0.5)*3);
      s.height = Math.max(ROWS-6, Math.min(ROWS-1, s.height + dh));
      for(let r = s.height; r<ROWS; r++) col[r] = '墙';
      s.runLeft -= 1;
    } else {
      // gap column
      // small chance of tall spike wall (vertical single wall) -- we skip
    }
  }

  // place coins or fire sparsely on the top of platform tiles
  for(let r=0;r<ROWS;r++){
    if(col[r] === '墙'){
      // top of platform: if the tile above is empty
      if(r>0 && col[r-1]===' '){
        const p = Math.random();
        if(p < 0.04) col[r-1] = '火';
        else if(p < 0.12) col[r-1] = '分';
        else if(p < 0.13) col[r-1] = '旗';
      }
    }
  }
  return col;
}

// initialize map with COLS columns
function initMap(){ mapCols = []; for(let i=0;i<COLS;i++) mapCols.push(generateColumn()); }

function respawn(){ player.x = canvas.width * 0.25; player.y = 0; player.vx = player.vy = 0; player.onGround = false; }
function resetAll(){ score = 0; deaths = 0; updateUI(); initMap(); respawn(); }
restartBtn.addEventListener('click',()=>{ if(confirm('重置得分与死亡计数，确认？')) resetAll(); });

function updateUI(){ scoreEl.textContent = score; deathsEl.textContent = deaths; }

function collideRectWithTile(px,py,pw,ph,tc,tr){ const tx = tc * TILE, ty = tr * TILE; return !(px+pw <= tx || px >= tx+TILE || py+ph <= ty || py >= ty+TILE); }

function physicsStep(dt){
  // input lateral control (player can move a bit)
  let left = keys['arrowleft'] || keys['a'];
  let right = keys['arrowright'] || keys['d'];
  const jump = keys[' '] || keys['spacebar'];
  if(left) player.vx = -player.speed;
  else if(right) player.vx = player.speed;
  else player.vx = 0;

  // gravity
  player.vy += 1400 * dt;
  if(jump && player.onGround){ player.vy = -player.jumpPower; player.onGround = false; }

  // horizontal movement
  player.x += player.vx * dt;
  // vertical integrate
  player.y += player.vy * dt;

  // world coordinates to tile indices
  // Because map is shifting left, player's world x relative to map column 0 is tracked by an offset
  // We'll treat mapCols[0] as the leftmost visible column at x=0

  // collision: determine which column indices the player's bounding box spans
  const leftCol = Math.floor((player.x) / TILE);
  const rightCol = Math.floor((player.x + player.w - 1) / TILE);
  const topRow = Math.floor(player.y / TILE);
  const bottomRow = Math.floor((player.y + player.h - 1) / TILE);

  // vertical collision against mapCols
  player.onGround = false;
  for(let c = leftCol; c <= rightCol; c++){
    for(let r = topRow; r <= bottomRow; r++){
      const ch = tileAt(c, r);
      if(ch !== ' ' && ch !== '分' && ch !== '旗'){
        if(collideRectWithTile(player.x, player.y, player.w, player.h, c, r)){
          // resolve
          // if coming down
          if(player.vy > 0){
            player.y = r * TILE - player.h - 0.001; player.vy = 0; player.onGround = true;
          } else if(player.vy < 0){
            player.y = (r+1) * TILE + 0.001; player.vy = 0;
          }
        }
      }
    }
  }

  // pickups/hazards at player's center
  const centerCol = Math.floor((player.x + player.w/2) / TILE);
  const centerRow = Math.floor((player.y + player.h/2) / TILE);
  const touched = tileAt(centerCol, centerRow);
  if(touched === '分'){
    score += 1; setTile(centerCol, centerRow, ' '); updateUI();
  }
  if(touched === '火' || player.y > canvas.height + 200){ deaths += 1; updateUI(); // respawn but keep map
    respawn(); }
  if(touched === '旗'){
    score += 5; updateUI(); setTile(centerCol, centerRow, ' ');
  }
}

// spawning and scrolling logic: keep accumulator, every spawnInterval seconds shift one column
function updateSpawner(dt){
  spawnTimer += dt * speedMultiplier;
  const scrollAmount = spawnTimer / spawnInterval;
  // when >=1, shift floor(scrollAmount) columns
  if(spawnTimer >= spawnInterval){
    const n = Math.floor(spawnTimer / spawnInterval);
    for(let i=0;i<n;i++){
      // shift map left
      shiftColumn();
      // append new column at right
      pushColumn(generateColumn());
      // increase score as player survives
      score += 1; updateUI();
    }
    spawnTimer = spawnTimer % spawnInterval;
    // optionally slowly increase difficulty
    speedMultiplier = Math.min(3, speedMultiplier + 0.02 * n);
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background grid faint
  ctx.globalAlpha = 0.03;
  for(let x=0;x<canvas.width;x+=TILE) ctx.fillRect(x,0,1,canvas.height);
  for(let y=0;y<canvas.height;y+=TILE) ctx.fillRect(0,y,canvas.width,1);
  ctx.globalAlpha = 1;

  // draw columns: mapCols[0] maps to x=0, etc.
  ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.font = Math.floor(TILE*0.9) + 'px monospace';
  for(let c=0;c<mapCols.length;c++){
    for(let r=0;r<ROWS;r++){
      const ch = tileAt(c,r);
      if(ch === ' ') continue;
      const x = c * TILE; const y = r * TILE;
      if(ch === '墙'){ ctx.fillStyle = '#9fb0ff'; ctx.globalAlpha = 0.95; ctx.fillText('墙', x+2, y+2); }
      else if(ch === '分'){ ctx.fillStyle = '#ffd966'; ctx.globalAlpha = 1; ctx.fillText('分', x + (TILE-ctx.measureText('分').width)/2, y+4); }
      else if(ch === '旗'){ ctx.fillStyle = '#8af0a0'; ctx.globalAlpha = 1; ctx.fillText('旗', x+4, y+4); }
      else if(ch === '火'){ ctx.fillStyle = '#ff6a6a'; ctx.globalAlpha = 1; ctx.fillText('火', x+4, y+4); }
      else { ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.9; ctx.fillText(ch, x+4, y+2); }
    }
  }
  ctx.globalAlpha = 1;

  // draw player
  ctx.font = Math.floor(player.h) + 'px monospace'; ctx.fillStyle = '#fff';
  ctx.fillText('你', Math.round(player.x), Math.round(player.y));
}

let last = null;
function loop(ts){ if(!last) last = ts; const dt = Math.min(0.05, (ts-last)/1000); last = ts; updateSpawner(dt); physicsStep(dt); draw(); requestAnimationFrame(loop); }

// init
initMap(); respawn(); updateUI(); requestAnimationFrame(loop);

</script>
</body>
</html>
