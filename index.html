<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>文字平台跳跃 — 用字做世界</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1020;color:#fff;font-family: 'Noto Sans SC', 'Microsoft Yahei', monospace;}
    #gameWrap{display:flex;gap:12px;padding:12px}
    canvas{background:linear-gradient(180deg,#0b1224,#071021);border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
    #ui{min-width:240px}
    .panel{background:rgba(255,255,255,0.03);padding:12px;border-radius:8px}
    h1{font-size:18px;margin:0 0 8px 0}
    button{background:#1f6feb;border:0;padding:8px 10px;border-radius:6px;color:white;cursor:pointer}
    .small{font-size:13px;color:#b8d0ff}
    .bigScore{font-size:28px;margin:6px 0}
    a{color:#9fd3ff}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="c" width="960" height="480"></canvas>
    <div id="ui">
      <div class="panel">
        <h1>文字平台跳跃</h1>
        <div class="small">所有物体都用文字呈现 — 墙用“墙”，旗子用“旗”，金币用“分”，火用“火”。</div>
        <div style="margin-top:8px">
          <div class="bigScore">得分: <span id="score">0</span></div>
          <div class="bigScore">死亡: <span id="deaths">0</span></div>
        </div>
        <div style="margin-top:10px">
          <button id="restartBtn">重开（重置全部）</button>
        </div>
        <hr style="margin:10px 0;border:none;border-top:1px solid rgba(255,255,255,0.04)">
        <div class="small">
          控制：← → / A D 移动，空格 跳跃。R 快速重生。<br>
          规则：触碰“分”获得分数；碰到“火”或跌出画面死亡；到达“旗”可下一关（简单示意）。
        </div>
      </div>
      <div class="panel" style="margin-top:10px">
        <h1>关卡编辑（可即刻生效）</h1>
        <div class="small">你可以在下面的文本里修改关卡字符（空格为空地）：</div>
        <textarea id="levelEditor" style="width:100%;height:220px;margin-top:8px;font-family:monospace;font-size:13px;">                                                                                
                                                                                
              旗                                                                 
                                                                                
                                                                                
                                                                                
                                                                                
      分                                                                         
                                                                                
  墙墙墙        墙墙墙墙    墙墙墙墙墙墙墙墙墙墙墙墙                          
                                                                                
                                                                                
                墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙                                
                                                                                
                                                                                
                                                                                
                                 火                                           
                                                                                
墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙墙</textarea>
        <div style="margin-top:8px;text-align:right">
          <button id="applyLevel">应用关卡</button>
        </div>
      </div>
    </div>
  </div>

<script>
// 文字平台跳跃 — 单文件实现
// 地图字符说明：'墙' = 砖块/墙体(实心), '分' = 可收集金币, '旗' = 终点, '火' = 危险, 空格 = 空地, '人' 可作为起点标记（可选）

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const deathsEl = document.getElementById('deaths');
const restartBtn = document.getElementById('restartBtn');
const levelEditor = document.getElementById('levelEditor');
const applyLevelBtn = document.getElementById('applyLevel');

const TILE = 36; // 字符格子大小
const COLS = Math.floor(canvas.width / TILE);
const ROWS = Math.floor(canvas.height / TILE);

let score = 0, deaths = 0;
let levelMap = [];

function parseLevel(text){
  // 拆成数组行，保证每行长度为 COLS
  const lines = text.split('\n').slice(0, ROWS);
  const map = [];
  for(let r=0;r<ROWS;r++){
    let line = (lines[r] || '').replace(/\t/g,'    ');
    // pad or trim
    if(line.length < COLS) line = line + ' '.repeat(COLS - line.length);
    if(line.length > COLS) line = line.slice(0,COLS);
    map.push(line.split(''));
  }
  return map;
}

function defaultLevel(){
  return parseLevel(levelEditor.value);
}

// player state
const player = {
  x: TILE*2 + 8,
  y: 0,
  w: TILE*0.6,
  h: TILE*0.9,
  vx:0, vy:0,
  speed:180,
  jumpPower:520,
  onGround:false
};n
let keys = {};

window.addEventListener('keydown',e=>{ keys[e.key.toLowerCase()] = true; if(e.key === 'r' || e.key === 'R'){ respawn(); }});
window.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()] = false; });

function tileAt(col,row){
  if(row<0 || row>=ROWS || col<0 || col>=COLS) return ' ';
  return levelMap[row][col];
}

function setTile(col,row,val){ if(row<0||row>=ROWS||col<0||col>=COLS) return; levelMap[row][col]=val; }

function worldToTile(x){ return Math.floor(x / TILE); }

function respawn(){
  // find '人' start tile if exists
  let start = null;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(levelMap[r][c] === '人') start = {c,r};
  if(start){ player.x = start.c * TILE + 4; player.y = start.r * TILE - player.h; }
  else { player.x = TILE*2+8; player.y = 0; }
  player.vx = player.vy = 0; player.onGround = false;
}

function resetAll(){ score = 0; deaths = 0; levelMap = defaultLevel(); respawn(); updateUI(); }

restartBtn.addEventListener('click',()=>{ if(confirm('重置得分与死亡计数，确认？')){ resetAll(); }});
applyLevelBtn.addEventListener('click',()=>{ levelMap = parseLevel(levelEditor.value); respawn(); });

function updateUI(){ scoreEl.textContent = score; deathsEl.textContent = deaths; }

function collideRectWithTile(px,py,pw,ph,tc,tr){
  const tx = tc * TILE, ty = tr * TILE;
  return !(px+pw <= tx || px >= tx+TILE || py+ph <= ty || py >= ty+TILE);
}

function physicsStep(dt){
  // input
  let left = keys['arrowleft'] || keys['a'];
  let right = keys['arrowright'] || keys['d'];
  const jump = keys[' '] || keys['spacebar'];
  if(left) player.vx = -player.speed;
  else if(right) player.vx = player.speed;
  else player.vx = 0;

  // gravity
  player.vy += 1400 * dt; // gravity

  // jump (single jump if onGround)
  if(jump && player.onGround){ player.vy = -player.jumpPower; player.onGround = false; }

  // integrate
  let nx = player.x + player.vx * dt;
  let ny = player.y + player.vy * dt;

  // collision check: horizontal
  const colsToCheckH = [Math.floor(player.y/TILE), Math.floor((player.y+player.h-1)/TILE)];
  if(player.vx !== 0){
    const sideCol = player.vx>0 ? Math.floor((nx + player.w)/TILE) : Math.floor(nx / TILE);
    for(const row of colsToCheckH){
      const ch = tileAt(sideCol,row);
      if(ch !== ' ' && ch !== '分' && ch !== '旗'){
        // collide
        if(collideRectWithTile(nx, player.y, player.w, player.h, sideCol, row)){
          // slide to edge
          if(player.vx > 0) nx = sideCol * TILE - player.w - 0.001;
          else nx = (sideCol+1) * TILE + 0.001;
          player.vx = 0;
        }
      }
    }
  }

  // collision check: vertical
  player.onGround = false;
  const rowsToCheckV = [Math.floor((ny)/TILE), Math.floor((ny + player.h)/TILE)];
  for(let col = Math.floor(nx/TILE); col <= Math.floor((nx+player.w-1)/TILE); col++){
    for(const row of rowsToCheckV){
      const ch = tileAt(col,row);
      if(ch !== ' ' && ch !== '分' && ch !== '旗'){
        if(collideRectWithTile(nx, ny, player.w, player.h, col, row)){
          if(player.vy > 0){
            // landing on top
            ny = row * TILE - player.h - 0.001;
            player.vy = 0; player.onGround = true;
          }else if(player.vy < 0){
            // hit head
            ny = (row+1) * TILE + 0.001; player.vy = 0;
          }
        }
      }
    }
  }

  player.x = nx; player.y = ny;

  // pickup coins and hazards
  const pc = worldToTile(player.x + player.w/2);
  const pr = Math.floor((player.y + player.h/2) / TILE);
  const touched = tileAt(pc,pr);
  if(touched === '分'){
    score += 1; setTile(pc,pr,' ');
    updateUI();
  }
  if(touched === '火' || player.y > canvas.height + 200){
    deaths += 1; updateUI(); respawn();
  }
  if(touched === '旗'){
    // simple: award big bonus and reset level
    score += 10; updateUI();
    // respawn to simulate next level
    alert('你到了旗子！获得 10 分，进入下一关（演示）。');
    // regenerate coins (simple) and respawn
    levelMap = defaultLevel(); respawn();
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background grid
  ctx.fillStyle = '#fff';
  ctx.globalAlpha = 0.02;
  for(let x=0;x<canvas.width;x+=TILE) ctx.fillRect(x,0,1,canvas.height);
  for(let y=0;y<canvas.height;y+=TILE) ctx.fillRect(0,y,canvas.width,1);
  ctx.globalAlpha = 1;

  // draw tiles as characters
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.font = Math.floor(TILE*0.9) + 'px monospace';

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const ch = levelMap[r][c];
      if(ch === ' ') continue;
      const x = c * TILE; const y = r * TILE;
      // style by char
      if(ch === '墙'){
        ctx.fillStyle = '#9fb0ff'; ctx.globalAlpha = 0.95;
        ctx.fillText('墙', x+2, y+2);
      } else if(ch === '分'){
        ctx.fillStyle = '#ffd966'; ctx.globalAlpha = 1;
        ctx.fillText('分', x+ (TILE-ctx.measureText('分').width)/2, y+4);
      } else if(ch === '旗'){
        ctx.fillStyle = '#8af0a0'; ctx.globalAlpha = 1;
        ctx.fillText('旗', x+4, y+4);
      } else if(ch === '火'){
        ctx.fillStyle = '#ff6a6a'; ctx.globalAlpha = 1;
        ctx.fillText('火', x+4, y+4);
      } else if(ch === '人'){
        ctx.fillStyle = '#cfe0ff'; ctx.globalAlpha = 1;
        ctx.fillText('人', x+4, y+2);
      } else {
        ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.9;
        ctx.fillText(ch, x+4, y+2);
      }
    }
  }
  ctx.globalAlpha = 1;

  // draw player as character '你' (or emoji)
  ctx.font = Math.floor(player.h) + 'px monospace';
  ctx.fillStyle = '#fff';
  const drawX = Math.round(player.x);
  const drawY = Math.round(player.y);
  ctx.fillText('你', drawX, drawY);

  // debug box
  // ctx.strokeStyle = 'red'; ctx.strokeRect(player.x, player.y, player.w, player.h);
}

let last = null;
function loop(ts){
  if(!last) last = ts; const dt = Math.min(0.05, (ts-last)/1000); last = ts;
  physicsStep(dt);
  draw();
  requestAnimationFrame(loop);
}

// init
levelMap = defaultLevel(); respawn(); updateUI(); requestAnimationFrame(loop);

</script>
</body>
</html>
