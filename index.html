<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>文字平台跳跃 - 无限生存模式</title>
<style>
  html, body {
    margin:0; padding:0; height:100%; background:#061025; color:#fff; font-family: monospace;
  }
  #container {
    display:flex; justify-content:center; align-items:center; height:100vh;
    user-select:none;
  }
  canvas {
    background: linear-gradient(180deg,#041220,#071821);
    border-radius:8px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.6);
  }
  #ui {
    position: fixed; top: 20px; right: 20px; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px;
    width: 220px;
  }
  #ui button {
    margin-top: 10px; width: 100%; padding: 8px; border:none; border-radius: 6px; background:#1f6feb; color:#fff; font-size: 16px; cursor:pointer;
  }
</style>
</head>
<body>
<div id="container">
  <canvas id="game" width="960" height="480"></canvas>
</div>
<div id="ui">
  <div>模式：<b>无限生存模式</b></div>
  <div>得分: <span id="score">0</span></div>
  <div>死亡: <span id="deaths">0</span></div>
  <button id="restart">重开（保留统计）</button>
</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const deathsEl = document.getElementById('deaths');
  const restartBtn = document.getElementById('restart');

  const TILE = 36;
  const ROWS = Math.floor(canvas.height / TILE);
  const COLS_VISIBLE = Math.ceil(canvas.width / TILE) + 2;

  let mapCols = [];
  let score = 0;
  let deaths = 0;
  let speedMultiplier = 1;

  const player = {
    x: canvas.width * 0.25,
    y: 0,
    w: TILE * 0.6,
    h: TILE * 0.9,
    vx: 0,
    vy: 0,
    speed: 180,
    jumpPower: 520,
    onGround: false
  };

  let keys = {};

  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  function emptyCol() {
    return new Array(ROWS).fill(' ');
  }

  function tileAt(col, row) {
    if (col < 0 || row < 0 || row >= ROWS) return ' ';
    const c = mapCols[col];
    if (!c) return ' ';
    return c[row] || ' ';
  }

  function setTile(col, row, ch) {
    if (col < 0 || row < 0 || row >= ROWS) return;
    if (!mapCols[col]) mapCols[col] = emptyCol();
    mapCols[col][row] = ch;
  }

  function generateColumn() {
    if (!generateColumn.state) generateColumn.state = { runLeft: 0, height: ROWS - 4 };
    const s = generateColumn.state;
    const col = emptyCol();

    if (s.runLeft > 0) {
      for (let r = s.height; r < ROWS; r++) col[r] = '墙';
      s.runLeft -= 1;
    } else {
      if (Math.random() < 0.6) {
        s.runLeft = Math.floor(Math.random() * 4) + 2;
        const dh = Math.floor((Math.random() - 0.5) * 3);
        s.height = Math.max(ROWS - 10, Math.min(ROWS - 2, s.height + dh));
        for (let r = s.height; r < ROWS; r++) col[r] = '墙';
        s.runLeft -= 1;
      }
    }

    // decorations
    for (let r = 0; r < ROWS; r++) {
      if (col[r] === '墙' && r > 0 && col[r - 1] === ' ') {
        const p = Math.random();
        if (p < 0.03) col[r - 1] = '火';
        else if (p < 0.10) col[r - 1] = '分';
        else if (p < 0.011) col[r - 1] = '旗';
      }
    }

    return col;
  }

  function initMap() {
    mapCols = [];
    const safeStart = 6;
    for (let i = 0; i < COLS_VISIBLE; i++) {
      const col = generateColumn();
      if (i < safeStart) {
        for (let r = ROWS - 3; r < ROWS; r++) col[r] = '墙';
      }
      mapCols.push(col);
    }
  }

  function respawn() {
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    player.x = canvas.width * 0.25;
    const col = Math.floor(player.x / TILE);

    let found = false;
    for (let r = 0; r < ROWS; r++) {
      if (tileAt(col, r) === '墙') {
        player.y = r * TILE - player.h - 0.5;
        found = true;
        break;
      }
    }

    if (!found) {
      for (let d = 1; d <= 10 && !found; d++) {
        for (const nc of [col + d, col - d]) {
          for (let r = 0; r < ROWS; r++) {
            if (tileAt(nc, r) === '墙') {
              player.y = r * TILE - player.h - 0.5;
              found = true;
              break;
            }
          }
          if (found) break;
        }
      }
    }

    if (!found) {
      player.y = (ROWS - 4) * TILE - player.h;
    }
  }

  let spawnAcc = 0;
  const spawnInterval = 0.45;

  function updateSpawner(dt) {
    spawnAcc += dt * speedMultiplier;
    if (spawnAcc >= spawnInterval) {
      const n = Math.floor(spawnAcc / spawnInterval);
      for (let i = 0; i < n; i++) {
        mapCols.shift();
        mapCols.push(generateColumn());
        score += 1;
        speedMultiplier = Math.min(3.5, speedMultiplier + 0.004);
      }
      spawnAcc = spawnAcc % spawnInterval;
      updateUI();
    }
  }

  function updateUI() {
    scoreEl.textContent = score;
    deathsEl.textContent = deaths;
  }

  function rectIntersectsTile(px, py, pw, ph, tc, tr) {
    const tx = tc * TILE, ty = tr * TILE;
    return !(px + pw <= tx || px >= tx + TILE || py + ph <= ty || py >= ty + TILE);
  }

  function physicsStep(dt) {
    const left = keys['arrowleft'] || keys['a'];
    const right = keys['arrowright'] || keys['d'];
    const jump = keys[' '] || keys['spacebar'];
    if (left) player.vx = -player.speed;
    else if (right) player.vx = player.speed;
    else player.vx = 0;

    player.vy += 1400 * dt;
    if (jump && player.onGround) {
      player.vy = -player.jumpPower;
      player.onGround = false;
    }

    let nx = player.x + player.vx * dt;
    let ny = player.y + player.vy * dt;

    // 横向碰撞
    const topRow = Math.floor(player.y / TILE);
    const bottomRow = Math.floor((player.y + player.h - 1) / TILE);
    if (player.vx !== 0) {
      const col = player.vx > 0 ? Math.floor((nx + player.w) / TILE) : Math.floor(nx / TILE);
      for (let row = topRow; row <= bottomRow; row++) {
        const ch = tileAt(col, row);
        if (ch !== ' ' && ch !== '分' && ch !== '旗') {
          if (rectIntersectsTile(nx, player.y, player.w, player.h, col, row)) {
            if (player.vx > 0) nx = col * TILE - player.w - 0.001;
            else nx = (col + 1) * TILE + 0.001;
            player.vx = 0;
            break;
          }
        }
      }
    }

    // 纵向碰撞
    const leftCol = Math.floor(nx / TILE);
    const rightCol = Math.floor((nx + player.w - 1) / TILE);
    player.onGround = false;
    for (let c = leftCol; c <= rightCol; c++) {
      for (let r = Math.floor(ny / TILE); r <= Math.floor((ny + player.h - 1) / TILE); r++) {
        const ch = tileAt(c, r);
        if (ch !== ' ' && ch !== '分' && ch !== '旗') {
          if (rectIntersectsTile(nx, ny, player.w, player.h, c, r)) {
            if (player.vy > 0) {
              ny = r * TILE - player.h - 0.001;
              player.vy = 0;
              player.onGround = true;
            } else if (player.vy < 0) {
              ny = (r + 1) * TILE + 0.001;
              player.vy = 0;
            }
          }
        }
      }
    }

    player.x = nx;
    player.y = ny;

    // 中心点所在块检测
    const centerCol = Math.floor((player.x + player.w / 2) / TILE);
    const centerRow = Math.floor((player.y + player.h / 2) / TILE);
    const touched = tileAt(centerCol, centerRow);

    if (touched === '分') {
      score += 1;
      setTile(centerCol, centerRow, ' ');
      updateUI();
    }

    if (touched === '火') {
      deaths += 1;
      score = 0;
      updateUI();
      respawn();
    }

    if (touched === '旗') {
      score += 10;
      setTile(centerCol, centerRow, ' ');
      updateUI();
    }

    if (player.y > canvas.height + 200) {
      deaths += 1;
      score = 0;
      updateUI();
      respawn();
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.globalAlpha = 0.04;
    ctx.fillStyle = '#fff';
    for (let x = 0; x < canvas.width; x += TILE) ctx.fillRect(x, 0, 1, canvas.height);
    for (let y = 0; y < canvas.height; y += TILE) ctx.fillRect(0, y, canvas.width, 1);
    ctx.globalAlpha = 1;

    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.font = Math.floor(TILE * 0.9) + 'px monospace';

    for (let c = 0; c < mapCols.length; c++) {
      for (let r = 0; r < ROWS; r++) {
        const ch = tileAt(c, r);
        if (ch === ' ') continue;
        const x = c * TILE;
        const y = r * TILE;
        if (ch === '墙') {
          ctx.fillStyle = '#9fb0ff';
          ctx.fillText('墙', x + 2, y + 2);
        } else if (ch === '分') {
          ctx.fillStyle = '#ffd966';
          ctx.fillText('分', x + (TILE - ctx.measureText('分').width) / 2, y + 4);
        } else if (ch === '火') {
          ctx.fillStyle = '#ff6a6a';
          ctx.fillText('火', x + 4, y + 4);
        } else if (ch === '旗') {
          ctx.fillStyle = '#8af0a0';
          ctx.fillText('旗', x + 4, y + 4);
        } else {
          ctx.fillStyle = '#fff';
          ctx.fillText(ch, x + 4, y + 2);
        }
      }
    }

    ctx.font = Math.floor(player.h) + 'px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText('你', Math.round(player.x), Math.round(player.y));
  }

  let lastTimestamp = null;
  let spawnAccumulator = 0;
  const spawnInterval = 0.45;

  function gameLoop(ts) {
    if (!lastTimestamp) lastTimestamp = ts;
    const dt = Math.min(0.05, (ts - lastTimestamp) / 1000);
    lastTimestamp = ts;

    spawnAccumulator += dt * speedMultiplier;
    if (spawnAccumulator >= spawnInterval) {
      const n = Math.floor(spawnAccumulator / spawnInterval);
      for (let i = 0; i < n; i++) {
        mapCols.shift();
        mapCols.push(generateColumn());
        score += 1;
        speedMultiplier = Math.min(3.5, speedMultiplier + 0.004);
      }
      spawnAccumulator %= spawnInterval;
      updateUI();
    }

    physicsStep(dt);
    draw();

    requestAnimationFrame(gameLoop);
  }

  restartBtn.addEventListener('click', () => {
    score = 0;
    deaths = 0;
    speedMultiplier = 1;
    initMap();
    respawn();
    updateUI();
  });

  initMap();
  respawn();
  updateUI();
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
